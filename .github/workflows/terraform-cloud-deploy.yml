name: Deploy to Terraform Cloud

on:
  workflow_dispatch:
    inputs:
      module_name:
        description: 'Module to deploy'
        required: true
        type: choice
        options:
          - app-service-plan-function
          - app-service-plan-web
          - function-app
          - monitoring
          - networking
          - private-endpoint
          - storage-account
          - service-bus
          - container-instances
          - application-insights
          - application-insights-billing
          - application-insights-function
          - application-insights-network
        default: 'app-service-plan-function'
      major_version:
        description: 'Major version number'
        required: false
        type: string
        default: '1'
      minor_version:
        description: 'Minor version number'
        required: false
        type: string
        default: '1'
      dry_run:
        description: 'Dry run (validate only, do not publish)'
        required: false
        type: boolean
        default: false

env:
  TF_VERSION: '1.13.1'

jobs:
  validate-and-deploy:
    name: Validate and Deploy Module
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          # Get current branch name
          BRANCH_NAME="${{ github.ref_name }}"

          # Generate version using pattern: MAJOR.MINOR.GITHUB_RUN_ID for master, MAJOR.MINOR-beta.GITHUB_RUN_ID for others
          MAJOR="${{ github.event.inputs.major_version }}"
          MINOR="${{ github.event.inputs.minor_version }}"
          PATCH="${{ github.run_number }}"

          # Check if we're on master/main branch
          if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
            VERSION="$MAJOR.$MINOR.$PATCH"
            echo "Branch: $BRANCH_NAME (production)"
          else
            VERSION="$MAJOR.$MINOR.$PATCH-beta"
            echo "Branch: $BRANCH_NAME (beta)"
          fi

          echo "Generated version: $VERSION"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "VERSION=$VERSION" >> "$GITHUB_ENV"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Validate inputs
        run: |
          # Validate module name
            if [[ ! "${{ github.event.inputs.module_name }}" =~ ^(app-service-plan-web|app-service-plan-function|function-app|monitoring|networking|storage-account|private-endpoint|service-bus|container-instances|application-insights|application-insights-billing|application-insights-function|application-insights-network)$ ]]; then
              echo "‚ùå Invalid module name: ${{ github.event.inputs.module_name }}"
              exit 1
            fi

          # Validate major version
          if [[ ! "${{ github.event.inputs.major_version }}" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Invalid major version: ${{ github.event.inputs.major_version }}"
            exit 1
          fi

          # Validate minor version
          if [[ ! "${{ github.event.inputs.minor_version }}" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Invalid minor version: ${{ github.event.inputs.minor_version }}"
            exit 1
          fi

          echo "‚úÖ Module: ${{ github.event.inputs.module_name }}"
          echo "‚úÖ Generated Version: $VERSION"
          echo "‚úÖ GitHub Run ID: ${{ github.run_id }}"
          echo "‚úÖ Dry Run: ${{ github.event.inputs.dry_run }}"

      - name: Check module directory exists
        run: |
          MODULE_PATH="modules/${{ github.event.inputs.module_name }}"
          if [ ! -d "$MODULE_PATH" ]; then
            echo "‚ùå Module directory $MODULE_PATH does not exist"
            exit 1
          fi
          echo "‚úÖ Module directory found: $MODULE_PATH"

      - name: Validate required files
        run: |
          MODULE_PATH="modules/${{ github.event.inputs.module_name }}"
          REQUIRED_FILES=("main.tf" "variables.tf" "outputs.tf" "versions.tf" "README.md")

          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$MODULE_PATH/$file" ]; then
              echo "‚ùå Required file $MODULE_PATH/$file is missing"
              exit 1
            fi
            echo "‚úÖ Found: $MODULE_PATH/$file"
          done

      - name: Install dependencies
        run: |
          # Install jq for JSON processing
          sudo apt-get update
          sudo apt-get install -y jq rsync

      - name: Setup Terraform Cloud credentials
        run: |
          mkdir -p ~/.terraform.d
          cat > ~/.terraform.d/credentials.tfrc.json << EOF
          {
            "credentials": {
              "app.terraform.io": {
                "token": "${{ secrets.TF_API_TOKEN }}"
              }
            }
          }
          EOF
          echo "‚úÖ Terraform Cloud credentials configured"

      - name: Validate Terraform configuration
        env:
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          MODULE_PATH="modules/${{ github.event.inputs.module_name }}"
          TEMP_DIR="/tmp/terraform-module-${{ github.event.inputs.module_name }}-$VERSION"

          echo "üîç Validating Terraform configuration for ${{ github.event.inputs.module_name }}"

          # Clean up any existing temp directory
          if [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
          fi

          # Create temporary directory and copy module files
          mkdir -p "$TEMP_DIR"
          rsync -av --exclude='examples/' --exclude='.terraform/' --exclude='.terraform.lock.hcl' "$MODULE_PATH/" "$TEMP_DIR/"

          # Validate in temp directory
          cd "$TEMP_DIR"

          # Initialize Terraform (backend=false for validation only)
          terraform init -backend=false

          # Format check
          if ! terraform fmt -check -recursive .; then
            echo "‚ö†Ô∏è Terraform formatting issues found. Running terraform fmt..."
            terraform fmt -recursive .
          fi

          # Validate configuration
          terraform validate

          echo "‚úÖ Terraform configuration is valid"

      - name: Create module package
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          ORGANIZATION="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          PROVIDER="azurerm"

          TARBALL_NAME="terraform-$ORGANIZATION-$MODULE_NAME-$PROVIDER-$VERSION.tar.gz"

          echo "üì¶ Creating module package..."
          echo "üìã Package details:"
          echo "  Module: $MODULE_NAME"
          echo "  Version: $VERSION"
          echo "  Organization: $ORGANIZATION"
          echo "  GitHub Run ID: ${{ github.run_id }}"

          # Create tarball
          cd /tmp
          tar -czf "$TARBALL_NAME" -C "terraform-module-$MODULE_NAME-$VERSION" .

          # Display package info
          echo "‚úÖ Package created: /tmp/$TARBALL_NAME"
          echo "üìä Package size: $(du -h "/tmp/$TARBALL_NAME" | cut -f1)"

          # Store package path for next step
          echo "TARBALL_PATH=/tmp/$TARBALL_NAME" >> "$GITHUB_ENV"

      - name: Publish to Terraform Cloud
        if: github.event.inputs.dry_run != 'true'
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          ORGANIZATION="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          PROVIDER="azurerm"
          TFC_API_URL="https://app.terraform.io/api/v2"

          echo "üöÄ Publishing module $MODULE_NAME version $VERSION to Terraform Cloud"

          # Step 1: Check if organization exists
          echo "üîç Checking organization: $ORGANIZATION"
          ORG_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            "$TFC_API_URL/organizations/$ORGANIZATION")

          if echo "$ORG_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "‚ùå Organization $ORGANIZATION not found or access denied"
            echo "Response: $ORG_RESPONSE"
            exit 1
          fi

          echo "‚úÖ Organization $ORGANIZATION found"

          # Step 2: Check if module exists, if not create it
          MODULE_FULL_NAME="$ORGANIZATION/$MODULE_NAME/$PROVIDER"
          echo "üîç Checking if module exists: $MODULE_FULL_NAME"

          MODULE_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER")

          if echo "$MODULE_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "üìù Module doesn't exist, creating new module: $MODULE_FULL_NAME"

            # Create module
            CREATE_MODULE_PAYLOAD=$(cat <<EOF
          {
            "data": {
              "type": "registry-modules",
              "attributes": {
                "name": "$MODULE_NAME",
                "provider": "$PROVIDER",
                "registry-name": "private"
              }
            }
          }
          EOF
          )

            CREATE_RESPONSE=$(curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              --header "Content-Type: application/vnd.api+json" \
              --request POST \
              --data "$CREATE_MODULE_PAYLOAD" \
              "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules")

            if echo "$CREATE_RESPONSE" | jq -e '.errors' > /dev/null; then
              echo "‚ùå Failed to create module"
              echo "Response: $CREATE_RESPONSE"
              exit 1
            fi

            echo "‚úÖ Module created successfully"
          else
            echo "‚úÖ Module already exists: $MODULE_FULL_NAME"
          fi

          # Step 3: Create a new version
          echo "üìù Creating module version $VERSION"

          CREATE_VERSION_PAYLOAD=$(cat <<EOF
          {
            "data": {
              "type": "registry-module-versions",
              "attributes": {
                "version": "$VERSION"
              }
            }
          }
          EOF
          )

          VERSION_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            --request POST \
            --data "$CREATE_VERSION_PAYLOAD" \
            "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER/versions")

          if echo "$VERSION_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "‚ùå Failed to create module version"
            echo "Response: $VERSION_RESPONSE"
            exit 1
          fi

          # Extract upload URL
          UPLOAD_URL=$(echo "$VERSION_RESPONSE" | jq -r '.data.links.upload')

          if [ "$UPLOAD_URL" = "null" ] || [ -z "$UPLOAD_URL" ]; then
            echo "‚ùå Failed to get upload URL from response"
            echo "Response: $VERSION_RESPONSE"
            exit 1
          fi

          echo "‚úÖ Module version created, upload URL obtained"

          # Step 4: Upload the tarball
          echo "üì§ Uploading module tarball..."
          echo "üìä Tarball size: $(du -h "$TARBALL_PATH" | cut -f1)"

          # Upload the tarball
          if curl -s --request PUT --upload-file "$TARBALL_PATH" "$UPLOAD_URL"; then
            echo "‚úÖ Module tarball uploaded successfully"
          else
            echo "‚ùå Failed to upload module tarball"
            exit 1
          fi

          # Step 5: Verify the module version was created
          echo "üîç Verifying module version..."
          sleep 5  # Give Terraform Cloud time to process

          VERIFY_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER/versions/$VERSION")

          if echo "$VERIFY_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "‚ö†Ô∏è Could not verify module version immediately (this is normal)"
          else
            STATUS=$(echo "$VERIFY_RESPONSE" | jq -r '.data.attributes.status')
            echo "‚úÖ Module version status: $STATUS"
          fi

      - name: Create Git tag
        if: github.event.inputs.dry_run != 'true'
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"

          # Create tag with module name and version
          TAG_NAME="$MODULE_NAME-v$VERSION"

          echo "üè∑Ô∏è Creating Git tag: $TAG_NAME"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git tag "$TAG_NAME"; then
            echo "‚úÖ Git tag $TAG_NAME created"
            echo "üì§ Pushing tag to repository..."
            git push origin "$TAG_NAME"
            echo "‚úÖ Tag pushed successfully"
          else
            echo "‚ö†Ô∏è Failed to create Git tag (tag may already exist)"
          fi

      - name: Display results
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          ORGANIZATION="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          PROVIDER="azurerm"

          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Module: $MODULE_NAME"
          echo "Version: $VERSION"
          echo "GitHub Run ID: ${{ github.run_id }}"
          echo "Organization: $ORGANIZATION"
          echo "Provider: $PROVIDER"
          echo "Dry Run: ${{ github.event.inputs.dry_run }}"

          if [ "${{ github.event.inputs.dry_run }}" != "true" ]; then
            echo ""
            echo "üîó Module URLs:"
            echo "Registry: https://app.terraform.io/$ORGANIZATION/modules/$MODULE_NAME/$PROVIDER/$VERSION"
            echo "Private Registry: https://app.terraform.io/$ORGANIZATION/registry/modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER"
            echo ""
            echo "üìã Usage in Terraform:"
            echo "module \"$MODULE_NAME\" {"
            echo "  source  = \"app.terraform.io/$ORGANIZATION/$MODULE_NAME/$PROVIDER\""
            echo "  version = \"$VERSION\""
            echo "  "
            echo "  # Add your module configuration here"
            echo "}"
            echo ""
            echo "üè∑Ô∏è Git Tag: $MODULE_NAME-v$VERSION"
          else
            echo ""
            echo "‚úÖ Dry run completed successfully - module is ready for publishing"
            echo "üìã Would create version: $VERSION"
          fi

      - name: Clean up
        if: always()
        run: |
          # Clean up temporary files
          rm -rf /tmp/terraform-module-*
          rm -f /tmp/terraform-*.tar.gz
          echo "üßπ Cleanup completed"

  update-readme:
    name: Update README.md Version
    needs: validate-and-deploy
    runs-on: ubuntu-latest
    # Only run on master branch and when not a dry run and when deployment was successful
    if: |
      github.ref == format('refs/heads/{0}', github.event.repository.default_branch) &&
      github.event.inputs.dry_run != 'true' &&
      needs.validate-and-deploy.result == 'success'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Use a personal access token to allow creating PRs
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Get latest module version
        id: get_version
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"

          # Get the latest tag for this module
          LATEST_TAG=$(git tag --sort=-version:refname | grep "^${MODULE_NAME}-v" | head -1)

          if [ -z "$LATEST_TAG" ]; then
            echo "‚ùå No tags found for module $MODULE_NAME"
            exit 1
          fi

          # Extract version from tag (remove module-name-v prefix)
          VERSION=$(echo "$LATEST_TAG" | sed "s/^${MODULE_NAME}-v//")

          echo "üìã Module: $MODULE_NAME"
          echo "üè∑Ô∏è Latest tag: $LATEST_TAG"
          echo "üì¶ Version: $VERSION"

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"

      - name: Update README.md
        id: update_readme
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          VERSION="${{ steps.get_version.outputs.version }}"

          echo "üìù Updating README.md for module $MODULE_NAME to version $VERSION"

          # Make script executable and run it
          chmod +x ./scripts/update-readme-version.sh

          if ./scripts/update-readme-version.sh "$MODULE_NAME" "$VERSION"; then
            echo "‚úÖ README.md updated successfully"
            echo "updated=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚ö†Ô∏è No updates were made to README.md"
            echo "updated=false" >> "$GITHUB_OUTPUT"
            exit 0  # Don't fail the job, just skip PR creation
          fi

      - name: Create Pull Request
        if: steps.update_readme.outputs.updated == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "docs: update ${{ github.event.inputs.module_name }} version to ${{ steps.get_version.outputs.version }} in README.md"
          title: "üìù Update ${{ github.event.inputs.module_name }} version to ${{ steps.get_version.outputs.version }}"
          body: |
            ## üìù Automated README.md Version Update

            This pull request automatically updates the version string for the `${{ github.event.inputs.module_name }}` module in the README.md Quick Start section.

            ### Changes Made
            - **Module**: `${{ github.event.inputs.module_name }}`
            - **New Version**: `${{ steps.get_version.outputs.version }}`
            - **Git Tag**: `${{ steps.get_version.outputs.tag }}`
            - **Deployment Run**: #${{ github.run_number }}

            ### Details
            This update was triggered by the successful deployment of `${{ github.event.inputs.module_name }}` version `${{ steps.get_version.outputs.version }}` to Terraform Cloud on the master branch.

            The following Quick Start sections have been updated:
            - Module-specific Quick Start example
            - Published Modules section (if applicable)

            ### Related
            - Terraform Cloud Deployment: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            - Module Tag: [${{ steps.get_version.outputs.tag }}](${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.tag }})

            ---
            *This PR was automatically created by the Terraform Cloud deployment workflow.*
          branch: "docs/update-${{ github.event.inputs.module_name }}-version-${{ steps.get_version.outputs.version }}"
          branch-suffix: timestamp
          delete-branch: true
          labels: |
            documentation
            automated
            version-update
          reviewers: |
            stuartshay
          draft: false

      - name: Summary
        if: always()
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          VERSION="${{ steps.get_version.outputs.version }}"
          UPDATED="${{ steps.update_readme.outputs.updated }}"

          echo "üéâ README Update Summary"
          echo "======================"
          echo "Module: $MODULE_NAME"
          echo "Version: $VERSION"
          echo "Updated: $UPDATED"

          if [ "$UPDATED" = "true" ]; then
            echo ""
            echo "‚úÖ A pull request has been created to update the README.md with the new version."
            echo "üìã The PR includes updates to the Quick Start section for the deployed module."
          else
            echo ""
            echo "‚ÑπÔ∏è No updates were needed for the README.md file."
          fi
