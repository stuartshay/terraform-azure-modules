name: Deploy to Terraform Cloud

on:
  workflow_dispatch:
    inputs:
      module_name:
        description: 'Module to deploy'
        required: true
        type: choice
        options:
          - app-service
          - monitoring
        default: 'app-service'
      major_version:
        description: 'Major version number'
        required: false
        type: string
        default: '1'
      minor_version:
        description: 'Minor version number'
        required: false
        type: string
        default: '1'
      dry_run:
        description: 'Dry run (validate only, do not publish)'
        required: false
        type: boolean
        default: false

env:
  TF_VERSION: '1.12.2'

jobs:
  validate-and-deploy:
    name: Validate and Deploy Module
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          # Get current branch name
          BRANCH_NAME="${{ github.ref_name }}"

          # Generate version using pattern: MAJOR.MINOR.GITHUB_RUN_ID for master, MAJOR.MINOR-beta.GITHUB_RUN_ID for others
          MAJOR="${{ github.event.inputs.major_version }}"
          MINOR="${{ github.event.inputs.minor_version }}"
          PATCH="${{ github.run_number }}"

          # Check if we're on master/main branch
          if [[ "$BRANCH_NAME" == "master" || "$BRANCH_NAME" == "main" ]]; then
            VERSION="$MAJOR.$MINOR.$PATCH"
            echo "Branch: $BRANCH_NAME (production)"
          else
            VERSION="$MAJOR.$MINOR.$PATCH-beta"
            echo "Branch: $BRANCH_NAME (beta)"
          fi

          echo "Generated version: $VERSION"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "VERSION=$VERSION" >> "$GITHUB_ENV"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Validate inputs
        run: |
          # Validate module name
          if [[ ! "${{ github.event.inputs.module_name }}" =~ ^(app-service|monitoring)$ ]]; then
            echo "‚ùå Invalid module name: ${{ github.event.inputs.module_name }}"
            exit 1
          fi

          # Validate major version
          if [[ ! "${{ github.event.inputs.major_version }}" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Invalid major version: ${{ github.event.inputs.major_version }}"
            exit 1
          fi

          # Validate minor version
          if [[ ! "${{ github.event.inputs.minor_version }}" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Invalid minor version: ${{ github.event.inputs.minor_version }}"
            exit 1
          fi

          echo "‚úÖ Module: ${{ github.event.inputs.module_name }}"
          echo "‚úÖ Generated Version: $VERSION"
          echo "‚úÖ GitHub Run ID: ${{ github.run_id }}"
          echo "‚úÖ Dry Run: ${{ github.event.inputs.dry_run }}"

      - name: Check module directory exists
        run: |
          MODULE_PATH="modules/${{ github.event.inputs.module_name }}"
          if [ ! -d "$MODULE_PATH" ]; then
            echo "‚ùå Module directory $MODULE_PATH does not exist"
            exit 1
          fi
          echo "‚úÖ Module directory found: $MODULE_PATH"

      - name: Validate required files
        run: |
          MODULE_PATH="modules/${{ github.event.inputs.module_name }}"
          REQUIRED_FILES=("main.tf" "variables.tf" "outputs.tf" "versions.tf" "README.md")

          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$MODULE_PATH/$file" ]; then
              echo "‚ùå Required file $MODULE_PATH/$file is missing"
              exit 1
            fi
            echo "‚úÖ Found: $MODULE_PATH/$file"
          done

      - name: Install dependencies
        run: |
          # Install jq for JSON processing
          sudo apt-get update
          sudo apt-get install -y jq rsync

      - name: Setup Terraform Cloud credentials
        run: |
          mkdir -p ~/.terraform.d
          cat > ~/.terraform.d/credentials.tfrc.json << EOF
          {
            "credentials": {
              "app.terraform.io": {
                "token": "${{ secrets.TF_API_TOKEN }}"
              }
            }
          }
          EOF
          echo "‚úÖ Terraform Cloud credentials configured"

      - name: Validate Terraform configuration
        run: |
          MODULE_PATH="modules/${{ github.event.inputs.module_name }}"
          TEMP_DIR="/tmp/terraform-module-${{ github.event.inputs.module_name }}-$VERSION"

          echo "üîç Validating Terraform configuration for ${{ github.event.inputs.module_name }}"

          # Clean up any existing temp directory
          if [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
          fi

          # Create temporary directory and copy module files
          mkdir -p "$TEMP_DIR"
          rsync -av --exclude='examples/' --exclude='.terraform/' --exclude='.terraform.lock.hcl' "$MODULE_PATH/" "$TEMP_DIR/"

          # Validate in temp directory
          cd "$TEMP_DIR"

          # Initialize Terraform (backend=false for validation only)
          terraform init -backend=false

          # Format check
          if ! terraform fmt -check -recursive .; then
            echo "‚ö†Ô∏è Terraform formatting issues found. Running terraform fmt..."
            terraform fmt -recursive .
          fi

          # Validate configuration
          terraform validate

          echo "‚úÖ Terraform configuration is valid"

      - name: Create module package
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          ORGANIZATION="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          PROVIDER="azurerm"

          TARBALL_NAME="terraform-$ORGANIZATION-$MODULE_NAME-$PROVIDER-$VERSION.tar.gz"

          echo "üì¶ Creating module package..."
          echo "üìã Package details:"
          echo "  Module: $MODULE_NAME"
          echo "  Version: $VERSION"
          echo "  Organization: $ORGANIZATION"
          echo "  GitHub Run ID: ${{ github.run_id }}"

          # Create tarball
          cd /tmp
          tar -czf "$TARBALL_NAME" -C "terraform-module-$MODULE_NAME-$VERSION" .

          # Display package info
          echo "‚úÖ Package created: /tmp/$TARBALL_NAME"
          echo "üìä Package size: $(du -h "/tmp/$TARBALL_NAME" | cut -f1)"

          # Store package path for next step
          echo "TARBALL_PATH=/tmp/$TARBALL_NAME" >> "$GITHUB_ENV"

      - name: Publish to Terraform Cloud
        if: github.event.inputs.dry_run != 'true'
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          ORGANIZATION="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          PROVIDER="azurerm"
          TFC_API_URL="https://app.terraform.io/api/v2"

          echo "üöÄ Publishing module $MODULE_NAME version $VERSION to Terraform Cloud"

          # Step 1: Check if organization exists
          echo "üîç Checking organization: $ORGANIZATION"
          ORG_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            "$TFC_API_URL/organizations/$ORGANIZATION")

          if echo "$ORG_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "‚ùå Organization $ORGANIZATION not found or access denied"
            echo "Response: $ORG_RESPONSE"
            exit 1
          fi

          echo "‚úÖ Organization $ORGANIZATION found"

          # Step 2: Check if module exists, if not create it
          MODULE_FULL_NAME="$ORGANIZATION/$MODULE_NAME/$PROVIDER"
          echo "üîç Checking if module exists: $MODULE_FULL_NAME"

          MODULE_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER")

          if echo "$MODULE_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "üìù Module doesn't exist, creating new module: $MODULE_FULL_NAME"

            # Create module
            CREATE_MODULE_PAYLOAD=$(cat <<EOF
          {
            "data": {
              "type": "registry-modules",
              "attributes": {
                "name": "$MODULE_NAME",
                "provider": "$PROVIDER",
                "registry-name": "private"
              }
            }
          }
          EOF
          )

            CREATE_RESPONSE=$(curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              --header "Content-Type: application/vnd.api+json" \
              --request POST \
              --data "$CREATE_MODULE_PAYLOAD" \
              "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules")

            if echo "$CREATE_RESPONSE" | jq -e '.errors' > /dev/null; then
              echo "‚ùå Failed to create module"
              echo "Response: $CREATE_RESPONSE"
              exit 1
            fi

            echo "‚úÖ Module created successfully"
          else
            echo "‚úÖ Module already exists: $MODULE_FULL_NAME"
          fi

          # Step 3: Create a new version
          echo "üìù Creating module version $VERSION"

          CREATE_VERSION_PAYLOAD=$(cat <<EOF
          {
            "data": {
              "type": "registry-module-versions",
              "attributes": {
                "version": "$VERSION"
              }
            }
          }
          EOF
          )

          VERSION_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            --request POST \
            --data "$CREATE_VERSION_PAYLOAD" \
            "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER/versions")

          if echo "$VERSION_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "‚ùå Failed to create module version"
            echo "Response: $VERSION_RESPONSE"
            exit 1
          fi

          # Extract upload URL
          UPLOAD_URL=$(echo "$VERSION_RESPONSE" | jq -r '.data.links.upload')

          if [ "$UPLOAD_URL" = "null" ] || [ -z "$UPLOAD_URL" ]; then
            echo "‚ùå Failed to get upload URL from response"
            echo "Response: $VERSION_RESPONSE"
            exit 1
          fi

          echo "‚úÖ Module version created, upload URL obtained"

          # Step 4: Upload the tarball
          echo "üì§ Uploading module tarball..."
          echo "üìä Tarball size: $(du -h "$TARBALL_PATH" | cut -f1)"

          # Upload the tarball
          if curl -s --request PUT --upload-file "$TARBALL_PATH" "$UPLOAD_URL"; then
            echo "‚úÖ Module tarball uploaded successfully"
          else
            echo "‚ùå Failed to upload module tarball"
            exit 1
          fi

          # Step 5: Verify the module version was created
          echo "üîç Verifying module version..."
          sleep 5  # Give Terraform Cloud time to process

          VERIFY_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            "$TFC_API_URL/organizations/$ORGANIZATION/registry-modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER/versions/$VERSION")

          if echo "$VERIFY_RESPONSE" | jq -e '.errors' > /dev/null; then
            echo "‚ö†Ô∏è Could not verify module version immediately (this is normal)"
          else
            STATUS=$(echo "$VERIFY_RESPONSE" | jq -r '.data.attributes.status')
            echo "‚úÖ Module version status: $STATUS"
          fi

      - name: Create Git tag
        if: github.event.inputs.dry_run != 'true'
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"

          # Create tag with module name and version
          TAG_NAME="$MODULE_NAME-v$VERSION"

          echo "üè∑Ô∏è Creating Git tag: $TAG_NAME"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git tag "$TAG_NAME"; then
            echo "‚úÖ Git tag $TAG_NAME created"
            echo "üì§ Pushing tag to repository..."
            git push origin "$TAG_NAME"
            echo "‚úÖ Tag pushed successfully"
          else
            echo "‚ö†Ô∏è Failed to create Git tag (tag may already exist)"
          fi

      - name: Display results
        run: |
          MODULE_NAME="${{ github.event.inputs.module_name }}"
          ORGANIZATION="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          PROVIDER="azurerm"

          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Module: $MODULE_NAME"
          echo "Version: $VERSION"
          echo "GitHub Run ID: ${{ github.run_id }}"
          echo "Organization: $ORGANIZATION"
          echo "Provider: $PROVIDER"
          echo "Dry Run: ${{ github.event.inputs.dry_run }}"

          if [ "${{ github.event.inputs.dry_run }}" != "true" ]; then
            echo ""
            echo "üîó Module URLs:"
            echo "Registry: https://app.terraform.io/$ORGANIZATION/modules/$MODULE_NAME/$PROVIDER/$VERSION"
            echo "Private Registry: https://app.terraform.io/$ORGANIZATION/registry/modules/private/$ORGANIZATION/$MODULE_NAME/$PROVIDER"
            echo ""
            echo "üìã Usage in Terraform:"
            echo "module \"$MODULE_NAME\" {"
            echo "  source  = \"app.terraform.io/$ORGANIZATION/$MODULE_NAME/$PROVIDER\""
            echo "  version = \"$VERSION\""
            echo "  "
            echo "  # Add your module configuration here"
            echo "}"
            echo ""
            echo "üè∑Ô∏è Git Tag: $MODULE_NAME-v$VERSION"
          else
            echo ""
            echo "‚úÖ Dry run completed successfully - module is ready for publishing"
            echo "üìã Would create version: $VERSION"
          fi

      - name: Clean up
        if: always()
        run: |
          # Clean up temporary files
          rm -rf /tmp/terraform-module-*
          rm -f /tmp/terraform-*.tar.gz
          echo "üßπ Cleanup completed"
