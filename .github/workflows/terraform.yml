name: Terraform Validation

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  TF_VERSION: "1.5.0"

jobs:
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest

    strategy:
      matrix:
        directory:
          - modules/monitoring
          - modules/monitoring/examples/basic
          - modules/monitoring/examples/complete

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      id: fmt
      run: terraform fmt -check -recursive
      working-directory: ${{ matrix.directory }}
      continue-on-error: true

    - name: Terraform Init
      id: init
      run: terraform init -backend=false
      working-directory: ${{ matrix.directory }}

    - name: Terraform Validate
      id: validate
      run: terraform validate
      working-directory: ${{ matrix.directory }}

    - name: Comment PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
          #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
          #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`

          <details><summary>Validation Output</summary>

          \`\`\`\n
          ${{ steps.validate.outputs.stdout }}
          \`\`\`

          </details>

          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ matrix.directory }}\`, Workflow: \`${{ github.workflow }}\`*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Run tfsec
      uses: aquasecurity/tfsec-action@v1.0.3
      with:
        working_directory: modules/monitoring
        soft_fail: true

    - name: Run Checkov
      id: checkov
      uses: bridgecrewio/checkov-action@master
      with:
        directory: modules/monitoring
        framework: terraform
        soft_fail: true
        output_format: sarif
        output_file_path: reports/results.sarif

    - name: Upload Checkov results to GitHub Advanced Security
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: reports/results.sarif

  documentation:
    name: Documentation Check
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Check README files exist
      run: |
        # Check main module README
        if [ ! -f "modules/monitoring/README.md" ]; then
          echo "ERROR: modules/monitoring/README.md not found"
          exit 1
        fi

        # Check example READMEs
        if [ ! -f "modules/monitoring/examples/basic/README.md" ]; then
          echo "ERROR: modules/monitoring/examples/basic/README.md not found"
          exit 1
        fi

        if [ ! -f "modules/monitoring/examples/complete/README.md" ]; then
          echo "ERROR: modules/monitoring/examples/complete/README.md not found"
          exit 1
        fi

        echo "All README files found"

    - name: Check for required sections in main README
      run: |
        README_FILE="modules/monitoring/README.md"

        # Check for required sections
        if ! grep -q "## Usage" "$README_FILE"; then
          echo "ERROR: Usage section not found in $README_FILE"
          exit 1
        fi

        if ! grep -q "## Requirements" "$README_FILE"; then
          echo "ERROR: Requirements section not found in $README_FILE"
          exit 1
        fi

        if ! grep -q "## Inputs" "$README_FILE"; then
          echo "ERROR: Inputs section not found in $README_FILE"
          exit 1
        fi

        if ! grep -q "## Outputs" "$README_FILE"; then
          echo "ERROR: Outputs section not found in $README_FILE"
          exit 1
        fi

        echo "All required sections found in README"

  release-check:
    name: Release Readiness
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check for version tags
      run: |
        # Get the latest tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
        echo "Latest tag: $LATEST_TAG"

        # Check if we need a new release
        if [ "$LATEST_TAG" = "none" ]; then
          echo "No tags found. Ready for initial release v0.1.0"
          echo "NEEDS_RELEASE=true" >> $GITHUB_ENV
          echo "SUGGESTED_VERSION=v0.1.0" >> $GITHUB_ENV
        else
          # Check if there are commits since the last tag
          COMMITS_SINCE_TAG=$(git rev-list ${LATEST_TAG}..HEAD --count)
          if [ "$COMMITS_SINCE_TAG" -gt 0 ]; then
            echo "Found $COMMITS_SINCE_TAG commits since $LATEST_TAG"
            echo "NEEDS_RELEASE=true" >> $GITHUB_ENV

            # Suggest next version (simple patch increment)
            CURRENT_VERSION=${LATEST_TAG#v}
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            PATCH=$((${VERSION_PARTS[2]} + 1))
            SUGGESTED_VERSION="v${VERSION_PARTS[0]}.${VERSION_PARTS[1]}.$PATCH"
            echo "SUGGESTED_VERSION=$SUGGESTED_VERSION" >> $GITHUB_ENV
          else
            echo "No commits since last tag. No release needed."
            echo "NEEDS_RELEASE=false" >> $GITHUB_ENV
          fi
        fi

    - name: Create release suggestion comment
      if: env.NEEDS_RELEASE == 'true' && github.event_name == 'push'
      uses: actions/github-script@v7
      with:
        script: |
          const { SUGGESTED_VERSION } = process.env;

          const body = `## üöÄ Release Suggestion

          The main branch has changes that could be released as version **${SUGGESTED_VERSION}**.

          To create a release:
          1. Create and push a new tag: \`git tag -a ${SUGGESTED_VERSION} -m "Release ${SUGGESTED_VERSION}"\`
          2. Push the tag: \`git push origin ${SUGGESTED_VERSION}\`
          3. Create a GitHub release from the tag

          This will make the module available at:
          \`\`\`hcl
          module "monitoring" {
            source = "github.com/stuartshay/terraform-azure-modules//modules/monitoring?ref=${SUGGESTED_VERSION}"
            # ... configuration
          }
          \`\`\``;

          // Create an issue for the release suggestion
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Release suggestion: ${SUGGESTED_VERSION}`,
            body: body,
            labels: ['release', 'enhancement']
          });
