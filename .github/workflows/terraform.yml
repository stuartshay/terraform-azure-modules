name: Terraform Validation

on:
  push:
    branches: [master, develop]
  pull_request:
    branches: [master]
  workflow_dispatch:

env:
  TF_VERSION: '1.12.2'

permissions:
  contents: read
  pull-requests: write
  issues: write
  security-events: write

jobs:
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest

    steps:
      - name: Checkout./.github/workflows/
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          # Configure Terraform CLI credentials for HCP Terraform (Terraform Cloud)
          # so that private registry modules can be accessed during init/validate
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Verify Terraform Cloud authentication
        env:
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          if [ -z "${TF_API_TOKEN:-}" ] || [ -z "${TF_CLOUD_ORGANIZATION:-}" ]; then
            echo "Skipping Terraform Cloud auth verification: TF_API_TOKEN or TF_CLOUD_ORGANIZATION not available (e.g., forked PR)."
            exit 0
          fi
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TF_API_TOKEN" \
            "https://app.terraform.io/api/v2/organizations/$TF_CLOUD_ORGANIZATION")
          if [ "$STATUS" != "200" ]; then
            echo "Failed to authenticate to Terraform Cloud (HTTP $STATUS) for org '$TF_CLOUD_ORGANIZATION'" >&2
            exit 1
          fi
          echo "Successfully authenticated to Terraform Cloud for org '$TF_CLOUD_ORGANIZATION'"

      - name: Find module directories (excluding examples)
        id: find_modules
        run: |
          # Find all directories containing .tf files, excluding examples
          MODULE_DIRS=$(find modules -name "*.tf" -type f | grep -v "/examples/" | xargs dirname | sort -u | tr '\n' ' ')
          echo "Found module directories: $MODULE_DIRS"
          echo "module_dirs=$MODULE_DIRS" >> "$GITHUB_OUTPUT"

      - name: Terraform Format Check
        id: fmt
        run: |
          read -ra DIRS <<< "${{ steps.find_modules.outputs.module_dirs }}"
          for dir in "${DIRS[@]}"; do
            echo "Checking format in $dir"
            terraform fmt -check -recursive "$dir" || echo "Format issues found in $dir"
          done
        continue-on-error: true

      - name: Terraform Init and Validate
        id: validate
        env:
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: |
          if [ -z "${TF_API_TOKEN:-}" ] || [ -z "${TF_CLOUD_ORGANIZATION:-}" ]; then
            echo "Skipping Terraform init/validate because TF_API_TOKEN or TF_CLOUD_ORGANIZATION is not available (e.g., forked PR)."
            exit 0
          fi
          read -ra DIRS <<< "${{ steps.find_modules.outputs.module_dirs }}"
          for dir in "${DIRS[@]}"; do
            echo "Validating $dir"
            cd "$dir"
            terraform init -backend=false -input=false -upgrade
            terraform validate
            cd - > /dev/null
          done

      - name: Comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const output = `#### Terraform Format and Style ðŸ–Œ\`${{ steps.fmt.outcome }}\`
            #### Terraform Validation ðŸ¤–\`${{ steps.validate.outcome }}\`

            <details><summary>Validation Output</summary>

            \`\`\`\n
            ${{ steps.validate.outputs.stdout }}
            \`\`\`

            </details>

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Verify Terraform Cloud authentication
        env:
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
        run: |
          if [ -z "${TF_API_TOKEN:-}" ] || [ -z "${TF_CLOUD_ORGANIZATION:-}" ]; then
            echo "Skipping Terraform Cloud auth verification: TF_API_TOKEN or TF_CLOUD_ORGANIZATION not available (e.g., forked PR)."
            exit 0
          fi
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TF_API_TOKEN" \
            "https://app.terraform.io/api/v2/organizations/$TF_CLOUD_ORGANIZATION")
          if [ "$STATUS" != "200" ]; then
            echo "Failed to authenticate to Terraform Cloud (HTTP $STATUS) for org '$TF_CLOUD_ORGANIZATION'" >&2
            exit 1
          fi
          echo "Successfully authenticated to Terraform Cloud for org '$TF_CLOUD_ORGANIZATION'"

      - name: Find module directories (excluding examples)
        id: find_modules
        run: |
          # Find all directories containing .tf files, excluding examples
          MODULE_DIRS=$(find modules -name "*.tf" -type f | grep -v "/examples/" | xargs dirname | sort -u | tr '\n' ' ')
          echo "Found module directories: $MODULE_DIRS"
          echo "module_dirs=$MODULE_DIRS" >> "$GITHUB_OUTPUT"

      - name: Run tfsec
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: |
          read -ra DIRS <<< "${{ steps.find_modules.outputs.module_dirs }}"
          for dir in "${DIRS[@]}"; do
            echo "Running tfsec on $dir"
            tfsec "$dir" --soft-fail || echo "tfsec issues found in $dir"
          done

      - name: Run Checkov
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}
        run: |
          read -ra DIRS <<< "${{ steps.find_modules.outputs.module_dirs }}"
          for dir in "${DIRS[@]}"; do
            echo "Running Checkov on $dir"
            checkov -d "$dir" --framework terraform --soft-fail --output sarif --output-file-path "reports/results-$(basename "$dir").sarif" || echo "Checkov issues found in $dir"
          done

      - name: Upload Checkov results to GitHub Advanced Security
        if: always()
        run: |
          # Create reports directory if it doesn't exist
          mkdir -p reports
          # Upload all SARIF files if they exist
          for sarif_file in reports/results-*.sarif; do
            if [ -f "$sarif_file" ]; then
              echo "Found SARIF file: $sarif_file"
              # Copy the first valid SARIF file as the combined result
              if [ ! -f "reports/results.sarif" ]; then
                cp "$sarif_file" reports/results.sarif
                echo "Using $sarif_file as combined results"
              fi
            fi
          done
        continue-on-error: true

      - name: Upload combined SARIF results
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: reports/results.sarif
        continue-on-error: true

  documentation:
    name: Documentation Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find module directories (excluding examples)
        id: find_modules
        run: |
          # Find all directories containing .tf files, excluding examples
          MODULE_DIRS=$(find modules -name "*.tf" -type f | grep -v "/examples/" | xargs dirname | sort -u | tr '\n' ' ')
          echo "Found module directories: $MODULE_DIRS"
          echo "module_dirs=$MODULE_DIRS" >> "$GITHUB_OUTPUT"

      - name: Check README files exist
        run: |
          read -ra DIRS <<< "${{ steps.find_modules.outputs.module_dirs }}"
          for dir in "${DIRS[@]}"; do
            # Check main module README
            if [ ! -f "$dir/README.md" ]; then
              echo "ERROR: $dir/README.md not found"
              exit 1
            fi
            echo "Found README: $dir/README.md"

            # Check example READMEs if examples directory exists
            if [ -d "$dir/examples" ]; then
              for example_dir in "$dir/examples"/*; do
                if [ -d "$example_dir" ] && [ ! -f "$example_dir/README.md" ]; then
                  echo "ERROR: $example_dir/README.md not found"
                  exit 1
                fi
                echo "Found example README: $example_dir/README.md"
              done
            fi
          done
          echo "All README files found"

      - name: Check for required sections in module READMEs
        run: |
          read -ra DIRS <<< "${{ steps.find_modules.outputs.module_dirs }}"
          for dir in "${DIRS[@]}"; do
            README_FILE="$dir/README.md"
            echo "Checking required sections in $README_FILE"

            # Check for required sections
            if ! grep -q "## Usage" "$README_FILE"; then
              echo "ERROR: Usage section not found in $README_FILE"
              exit 1
            fi

            if ! grep -q "## Requirements" "$README_FILE"; then
              echo "ERROR: Requirements section not found in $README_FILE"
              exit 1
            fi

            if ! grep -q "## Inputs" "$README_FILE"; then
              echo "ERROR: Inputs section not found in $README_FILE"
              exit 1
            fi

            if ! grep -q "## Outputs" "$README_FILE"; then
              echo "ERROR: Outputs section not found in $README_FILE"
              exit 1
            fi

            echo "All required sections found in $README_FILE"
          done

  release-check:
    name: Release Readiness
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for version tags
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "Latest tag: $LATEST_TAG"

          # Check if we need a new release
          if [ "$LATEST_TAG" = "none" ]; then
            echo "No tags found. Ready for initial release v0.1.0"
            echo "NEEDS_RELEASE=true" >> "$GITHUB_ENV"
            echo "SUGGESTED_VERSION=v0.1.0" >> "$GITHUB_ENV"
          else
            # Check if there are commits since the last tag
            COMMITS_SINCE_TAG=$(git rev-list "$LATEST_TAG"..HEAD --count)
            if [ "$COMMITS_SINCE_TAG" -gt 0 ]; then
              echo "Found $COMMITS_SINCE_TAG commits since $LATEST_TAG"
              echo "NEEDS_RELEASE=true" >> "$GITHUB_ENV"

              # Suggest next version (simple patch increment)
              CURRENT_VERSION="${LATEST_TAG#v}"
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              PATCH=$((VERSION_PARTS[2] + 1))
              SUGGESTED_VERSION="v${VERSION_PARTS[0]}.${VERSION_PARTS[1]}.$PATCH"
              echo "SUGGESTED_VERSION=$SUGGESTED_VERSION" >> "$GITHUB_ENV"
            else
              echo "No commits since last tag. No release needed."
              echo "NEEDS_RELEASE=false" >> "$GITHUB_ENV"
            fi
          fi

      - name: Create release suggestion comment
        if: env.NEEDS_RELEASE == 'true' && github.event_name == 'push'
        uses: actions/github-script@v7
        with:
          script: |
            const { SUGGESTED_VERSION } = process.env;

            const body = `## ðŸš€ Release Suggestion

            The main branch has changes that could be released as version **${SUGGESTED_VERSION}**.

            To create a release:
            1. Create and push a new tag: \`git tag -a ${SUGGESTED_VERSION} -m "Release ${SUGGESTED_VERSION}"\`
            2. Push the tag: \`git push origin ${SUGGESTED_VERSION}\`
            3. Create a GitHub release from the tag

            This will make the module available at:
            \`\`\`hcl
            module "monitoring" {
              source = "github.com/stuartshay/terraform-azure-modules//modules/monitoring?ref=${SUGGESTED_VERSION}"
              # ... configuration
            }
            \`\`\``;

            // Create an issue for the release suggestion
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Release suggestion: ${SUGGESTED_VERSION}`,
              body: body,
              labels: ['release', 'enhancement']
            });
